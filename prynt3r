#!/usr/bin/env python3

# == Prynt3r, a python-based 3D printing CLI tool, written by Rene K. Mueller <spiritdude@gmail.com>
#
# License: GPL
#
# Description:
#  This is a rewrite of Print3r (perl) in Python, hence the Prynt3r as name.
#  It provides a slicer agnostic CLI to slice, preview, print local and remote.
#
# Topology of Settings:
#
#     cli args       printer/<printer>.ini  slicer/<slicer>/base.ini 
#            \               +                     +
#   conf{}:   +----+          \                     \
#                   \          \                     \
#   slicing{}:       +----------+---------------------+---x-------------- slicer-exe -> gcode
#                                                        /
#                                            slicer/<slicer>/map.ini
#
# History:
# 2023/01/24: 0.0.9: fixing os.rename() -> shutil.move() for temporary files
# 2023/01/13: 0.0.8: adding .3mj support as well, and webcam support again (like print3r), early -d rrf:<ip> RepRapFirmware support
# 2023/01/09: 0.0.7: support for svg (via openscad) added
# 2023/01/05: 0.0.6: experimental vdb import capability, more refined usage message
# 2023/01/03: 0.0.5: maturing reliability, update, remote printing, log query, prepend_gcode added
# 2022/12/30: 0.0.3: macros work as well, fine-tuning remote printing
# 2022/12/28: 0.0.2: mostly functional, slicers work: slic3r, prusa, cura5, cura-slicer, lab, voxgl, vox3l (not yet super, kirimoto, mandoline, goslice, enoch, metatron, 5dmaker, zplus)
# 2022/12/19: 0.0.1: cli args parsed, early .ini parsing without conditional variables, local and remote printer access works
# 2022/12/17: start coding

import sys, os, re, subprocess, json, time, datetime, serial, math, random, uuid, signal, shutil
import trimesh
import perl5

APPNAME = "Prynt3r"
VERSION = "0.1.0-beta2"
APPREPO = f"https://github.com/Spiritdude/{APPNAME}"

me = os.path.basename(sys.argv.pop(0))

tmp = [ ]

basedirs = [ "/usr/share/prynt3r", os.path.join(os.getenv('HOME'),".config/prynt3r") ]
 
banner = f"""          ____    .              __ _____         .
     *   / __ \_______* ______  / /|__  /_____                 *
        / /_/ / ___/ / / / __ \/ __//_ </ ___/  .         |             *
   .   / ____/ /  / /_/ / / / / /____/ / /              -=*=-      .   
      /_/   /_/   \__, /_/ /_/\__/____/_/        *   .    |
                 /____/                     V{VERSION}           *          .
      {APPREPO}
""" 

conf = {
   'verbose': 0,
   'printer': 'default',
   'device': '/dev/ttyUSB0',
   'baudrate': 115200,
   'slicer': 'slic3r',
   'gcode_viewer': 'yagv',
   'recenter': 1,
   'relevel': 1,
   'display_update': 1,
   'placement': 'center',
   'gcode_info': 'head',
   'keep': 0,
   'quiet': 0
}
conf_src = { }

slicing = { 
   'machine_name': "Unknown",
   'machine_uuid': "",
   'machine_width': 200,
   'machine_depth': 200,
   'machine_height': 200,
   'nozzle_diameter': 0.4,
   'line_width': 0.4,
   'layer_height': 0.25,
   'filament_diameter': 1.75,
}

intern_keys = { k: 1 for k in conf } | { 
   k: 1 for k in 'placement rotate scale multiply_part scad scadlib zcad jscad'.split(' ') 
}   
slicer = { }

def preg_match(r,s,m):
   m.clear()
   _m = re.search(r,s)
   if _m:
      m.append(s)
      m.extend(_m.groups())
      return True
   return False

def usage():
   print(f"{banner}")
   print(f"""{APPNAME} {VERSION} USAGE: [<opts>] <cmd> <arg1> ...

   commands:
      slice <file1> ...    slice file(s) into single gcode, e.g. use -o <fn> or --output=<fn>
      print <file1> ...    slice and send gcode to printer local or remote, e.g. define -d <dev> or --device=<dev>
      preview <file1> ...  slice file(s) into single gcode and launch gcode viewer
      gconsole             starts interactive g-code console
      log [<s>] [#<n>]     list log, query term <s> or list log entry '#<n>', with --output or -o you can list only particulars
      client               start client process, so remote {me} can access it
""")
   print("   file-formats:")
   print(f"      stl, obj, off, 3mf, ply, {', '.join(list(preproc.keys()))}")
   print(f"""
   options:
      --help               print this message
      --version            print version and exit
      
      --device=<dev>       set device (default: {conf['device']})
        -d <dev>
   
      --printer=<name>     set printer name (default: {conf['printer']})
        -p <name>
   
      --slicer=<slicer>    set slicer: {", ".join(slicer.keys())}, (default: {conf['slicer']})
        -s <slicer>

      --gcode-viewer=<cmd> set gcode previewer (default: {conf['gcode_viewer']})

      --verbose=<n>        increase verbosity
         -vvv
      --extended or -x     extended output, e.g. for 'log' command
      
      --quiet or -q        stay quiet, only output warnings or errors

      --output=<fn>        slice: slicing into a particular file '{me} slice cube.stl -o test.gcode' or
         -o <fn>              log: '{me} log -o uid,files,args' to list particular fields of the log file
      
      --placement=<loc>    set location: 'none', 'center', 'random' (default: none)
      
      --rotate=<x>,<y>,<z> rotate model(s)
      --scale=<f>          scale model(s) uniformly
      --scale=<x>,<y>,<z>  scale model(s), if value has 'mm' appended, then axis is set absolute
                              e.g. "0,0,20mm" scales model(s) to 20mm Z height, all axes with 0 scales 
                              proportionally

      --multiply-part=<n>  multiply model(s)

      --recenter=<s>       recenter models (default: {conf['recenter']}), recommended when rotating
      --relevel=<s>        relevel models (default: {conf['relevel']}), recommended when rotating

      --uid=<uid>          set uid for print process (otherwise unique will be generated)
      --keep               keep all temporary files (for debugging)
      
      --scad               treat arguments as OpenSCAD code, e.g. --scad 'cube(20)'
         --scadlib=<lib>[,<lib2>]   consider libraries as well, e.g. --scadlib=parts.scad
      --zcad               treat arguments as OpenZCAD code
      --jscad              treat arguments as OpenJSCAD code""")

   #for l in inline_code:        # -- above is more informative than machine generated
   #   print(f"      --{l:<18} treat argument as {l}-code, e.g. --{l} '{l} code'")

   print(f"""
   slicing options (slicer independent):""")
   for k,v in slicing.items():
      k_ = re.sub('_','-',k)
      ks = re.sub('_',' ',k)
      print(f"      --{k_}=<v>{' '*(20-len(k_))} set {ks} (default: {json.dumps(v)})")
   print(f"""
   examples:
      {me} print cube.stl
      {me} print cube.scad
      {me} -p prusa-i3 print --scad 'cube(20)'
      {me} -p ashtar-k-1 -s cura5 slice cube.3mf
      {me} -p ashtar-k-1 -s cura5 print structure.vdb -d tcp:192.168.1.32:0
      {me} -s prusa slice cube.stl -o a.gcode 
      {me} preview cube.stl 
      {me} log 
      {me} log cube.stl -v
      {me} log '#100' -xv
      {me} log -o uid,args,files
      {me} -d /dev/ttyACM0 client &
      {me} -d /dev/ttyACM1 gconsole
      > M115
""")
   sys.exit(0)

_tmpid = 0
def tmpfn(ext="tmp"):
   global _tmpid
   uid = os.getpid()
   fn = f"/tmp/prynt3r-{uid}-{_tmpid}.{ext}"
   _tmpid += 1
   return fn

def clean_exit(*args,exit=0):
   if not conf['keep']:
      lprint("removing temp files",tmp)
      for f in tmp:
         if os.path.exists(f):
            os.remove(f)
   lprint(f"exit process {os.getpid()} with {exit}")
   sys.exit(exit)

def parse_ini(f):
   c = { }
   if not os.path.exists(f):
      eprint(f"file <{f}> doesn't exist, ignored")
      return c
   if type(f)==str:
      lprint(f"process {f}")
      fh = open(f,"r")
   else:
      fh = f
   for l in fh.readlines():
      l = l.rstrip()
      if re.search('^\s*#',l):
         continue
      m = [ ]
      if preg_match('^([\w\-]+)\s*=\s*(.*)',l,m):
         k,v = m[1],m[2]
         k = re.sub('-','_',k)
         v = re.sub('^\s*','',v)
         v = re.sub('^\s*"([^"]*)"\s*$',lambda m: m.group(1),v)     # -- remove "" if entire line
         c[k] = v
      elif preg_match('^\s{3,}(\S.*)',l,m):
         v = m[1]
         v = re.sub('^\s*"([^"]*)"\s*$',lambda m: m.group(1),v)     # -- remove "" if entire line
         c[k] += "\n" + v
      elif len(l):
         lprint(f"WARN: '{f}': strange line to parse: '{l}'",level=0)
   return c

def remap(s,c):
   vm = perl5.VM()

   def peval(s):
      lprint(f"   perl-eval: '{s}'",level=3)
      v = ''
      try:
         v = vm.eval(s)
      except Exception as e:
         eprint(f"evaluation of '{s}' caused error: '{e}'")
      if hasattr(v,'decode'): 
         v = v.decode()
      v = str(v)
      lprint(f"   == '{v}'",level=3)
      return v

   def expr_repl(a):
      a = a.groups()
      s = a[0]
      lprint(f"expr-repl: '{s}'",level=3)
      return peval(s)

   def var_repl(a):
      a = a.groups()
      k = a[0]
      lprint(f"var-repl: {k}",level=3)
      if k in s:
         return s[k]
      if k in c:
         return c[k]
      else:
         eprint(f"variable <{k}> referenced but not defined")
      return str(0)
      
   lprint(f"mapping: {c}",level=3)
   
   m = [ ]
   for k,v in s.items():
      lprint(f"mapping {k}: '{v}'",level=3)
      if k in c:
         v = c[k]
         lprint(f"  => '{v}'",level=3)
      if type(v)!=str:
         v = str(v)
      v = re.sub('\$(\w+)',var_repl,v)                # -- replace all vars [1]: $a
      v = re.sub('\$\{(\w+)\}',var_repl,v)            # -- replace all vars [2]: ${a}
      v = re.sub('\{([^\}]*)\}',expr_repl,v)          # -- eval entire expression: { expr }
      v = re.sub('\\\\n','\n',v)
      lprint(f"=> {k}: '{v}'",level=3)
      s[k] = v
         
def sliceMesh(f,fo,ms):
   global slicing
   
   if type(f)==list or type(f)==tuple:
      for _ in f:
         if not os.path.exists(_):
            eprint(f"cannot slice mesh, file <{_}> doesn't exist, ignored")
         m = re.search('\.(\w+)$',_)
         ext = m[1]
         if conf['slicer'] in slicer and ext not in slicer[conf['slicer']]['formats'].keys():
            eprint(f"slicer <{conf['slicer']}> does not support format '{ext}'",exit=1)
   else:
      if not os.path.exists(f):
         eprint(f"cannot slice mesh, file <{f}> doesn't exist, ignored")
         return 
      m = re.search('\.(\w+)$',_)
      ext = m[1]
      if ext not in slicer[conf['slicer']]['formats'].keys():
         eprint(f"slicer <{conf['slicer']}> does not support format '{ext}'",exit=1)
   
   if conf['slicer'] not in slicer:
      lprint(f"WARN: slicer <{conf['slicer']}> not officially supported, trying anyway",level=0)
      cmd = [conf['slicer'],'-o',fo]

   if conf['slicer'] in ['cura','cura4','cura5']:                 # -- covering all curas
      cmd = [slicer[conf['slicer']]['exe'],'slice','-o',fo]
      cmd.extend(['-j',os.path.join("/usr/share/prynt3r/slicer/",conf['slicer'],"fdmprinter.def.json")])
      cmd.extend(['-s','extruder_nr=0'])

      for k,v in parse_ini(os.path.join("/usr/share/prynt3r/slicer/",conf['slicer'],"base.ini")).items():
         if k not in slicing:
            slicing[k] = v
      
      remap(slicing,parse_ini(os.path.join("/usr/share/prynt3r/slicer/",conf['slicer'],"map.ini")))

      for k,v in slicing.items():
         if not k in intern_keys:
            cmd.extend(['-s',f"{k}={str(v)}"])
      if type(f)==list or type(f)==tuple:
         for _ in f:
            cmd.extend(['-l',_])
      else:
         cmd.extend(['-l',f])
      p = execx(cmd)

   else:                                                          # -- all others
      if conf['slicer'] in slicer:
         cmd = [slicer[conf['slicer']]['exe'],'-o',fo]
         
      if conf['slicer'] in [ 'slic3r', 'prusa', 'super' ]:
         cmd.append('--merge')                                    # -- merge multiple mesh(s)
         cmd.append('--before-layer-gcode=;LAYER:[layer_num]')    # -- make it cura-like gcode
         cmd.append('--gcode-comments')
      if conf['slicer'] in [ 'prusa', 'super' ]:
         cmd.append('--export-gcode')                             # -- avoid GUI
      if conf['verbose']>1:
         if conf['slicer'] in [ 'prusa', 'super' ]:
            cmd.append(f"--loglevel={conf['verbose']-1}")
         elif conf['slicer'] == 'slic3r':
            pass
         else:
            cmd.append('-'+'v'*(conf['verbose']-1))

      for k,v in parse_ini(os.path.join("/usr/share/prynt3r/slicer/",conf['slicer'],"base.ini")).items():
         if k not in slicing:
            slicing[k] = v
      
      remap(slicing,parse_ini(os.path.join("/usr/share/prynt3r/slicer/",conf['slicer'],"map.ini")))

      if conf['slicer'] in [ 'slic3r', 'prusa', 'super' ]:        
         # -- we store setting in --load file.ini (some settings are only available in .ini but not on CLI)
         fi = tmpfn("ini")
         tmp.append(fi)
         fh = open(fi,"w")
         for k,v in slicing.items():
            v = re.sub('\n','\\\\n',v)
            print(f"{k} = {v}",file=fh)
         fh.close()
         cmd.extend(['--load',fi]) 

      else:
         for k,v in slicing.items():
            v = re.sub('\n','\\\\n',v)
            cmd.extend([f'--{k}={v}'])

      if 'placement' in conf:
         for k in "machine_width,machine_depth,machine_height".split(","):
            slicing[k] = float(slicing[k])
         mm = ms.bounds
         sz = mm[1]-mm[0]
         if conf['placement']!='none':
            pos = [slicing['machine_width']/2,slicing['machine_depth']/2,0]
            if conf['placement']=='random':
               pos[0] += random.uniform(-1,1)*(slicing['machine_width']*.45-sz[0]/2)
               pos[1] += random.uniform(-1,1)*(slicing['machine_depth']*.45-sz[1]/2)
            if conf['slicer']=='kirimoto':
               cmd.extend([f"--bedOrigin={pos[0]:.0f},{pos[1]:.0f}","--outputOriginCenter=true"])
            elif conf['slicer']=='goslice':
               cmd.extend([f"--center={pos[0]*1000:.0f},{pos[1]*1000:.0f}"])
            elif conf['slicer']=='slic3r':
               cmd.extend([f"--print-center={pos[0]:.0f},{pos[1]:.0f}"])
            elif conf['slicer'] in ['prusa','super']:
               cmd.extend([f"--center={pos[0]:.0f},{pos[1]:.0f}"])
            else:
               cmd.extend([f"--bed_center={pos[0]:.0f},{pos[1]:.0f}"])
      
      if type(f)==list or type(f)==tuple:
         cmd.extend(f)
      else:
         cmd.append(f)
      p = execx(cmd)
      
   if not os.path.exists(fo) or os.path.getsize(fo)==0:
      eprint(f"slicer produced no G-code: {p}",exit=1)

   if 'gcode_info' in conf and conf['gcode_info'] in ['head','tail']:
      if conf['gcode_info'] == 'head':
         fo2 = tmpfn("gcode")
      else:
         fo2 = fo
      with open(fo2,"a") as fh:
         for l in banner.split("\n"):
            print(f"; {l}",file=fh)
         print(f"; created {datetime.datetime.now().isoformat()}",file=fh)
         for k,v in slicing.items():
            print(f";   {k} = {json.dumps(v)}",file=fh)
         if conf['gcode_info'] == 'head':
            with open(fo,"r") as fh2:
               fh.write(fh2.read())                   # -- FIXME: not sure if this is most efficient
            fh.close()
            shutil.move(fo2,fo)
         else:
            fh.close()
      
def previewGcode(f):
   if not os.path.exists(f):
      eprint(f"cannot preview file <{f}> as it doesn't exist, ignored")
      return
   execx([conf['gcode_viewer'],f])
   
def deviceLock(d,set=0,unset=0,update=0):
   dn = re.sub('[^\w\-]+','-',os.path.basename(d))
   lfn = os.path.join("/tmp","prynt3r-"+dn+".lock")
   if unset:
      if os.path.exists(lfn):
         os.remove(lfn)
      return
   if not update and os.path.exists(lfn) and (time.time()-os.path.getmtime(lfn))<15:
      eprint(f"device {d} is locked by another {me} process, abort",exit=-1)
   if set:
      tmp.append(lfn)
   if set or update:
      print(os.getpid(),file=open(lfn,"w"))
      
def writeSerial(ser,s):
   try:
      ser.write(s.encode())
   except Exception as e:
      eprint(f"exception {e} occured",exit=1)

def readSerial(ser,timeout=10,on_error=''):
   r = ''
   st = time.time()
   while 1:
      while 1:
         _ = ser.read(255)
         r += _.decode()
         if len(_)<255:
            break
         time.sleep(0.05)
      if re.search('ok\n',r):
         return r
      time.sleep(0.05)
      if time.time()-st > timeout:
         lprint("WARN: read timeout occured on serial, device endpoint seems unresponsive",level=0)
         return on_error

def connectSerial(d):
   m = [ ]

   deviceLock(d,set=1)

   backend = 'serial'

   if preg_match("^tcp:(\S+)",d,m):
      host = m[1]
      n = 0
      if preg_match("^([^:]+):(\d+)$",host,m):
         host = m[1]
         n = int(m[2])
      if 0:
         import socket
         sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
         try:
            sock.connect((host,3380+n))
            sock.write = sock.send
            sock.read = sock.recv
            return sock
         except Exception as e:
            eprint(f"failed to connect {host}:{n}",exit=1)
      else:
         sdev = os.path.join("/tmp",f"prynt3r-device-{host}-{n}")
         n += 3380
         if not os.path.exists(sdev):
            if os.fork()==0:
               def do_nothing(*args):
                  pass
               #signal.signal(signal.SIGINT,sigint_orig)     # -- reset SIGINT 
               signal.signal(signal.SIGINT,do_nothing)      # -- do nothing, but die silently instead
               lprint(f"child[1] process {os.getpid()}",level=3)
               if 1 or os.fork()==0:
                  #lprint("child[2] process {os.getpid()}",level=3)
                  lprint(f"launch socat {host}:{n} ({sdev})")
                  # -- NOTE: crtscts screws up communication reliability in this case (don't use it)
                  lprint(['socat',f'pty,raw,echo=0,b{conf["baudrate"]},link={sdev}',f'tcp:{host}:{n}'],level=2)
                  subprocess.run(['socat',f'pty,raw,echo=0,b{conf["baudrate"]},link={sdev}',f'tcp:{host}:{n}'])
                  lprint("socat exited")
                  sys.exit(0)
               #os.wait()
               lprint(f"socat ended")
               if os.path.exists(sdev):
                  os.remove(sdev)
               sys.exit(0)
            time.sleep(0.5)              # -- give it time to startup because we probe the link as next
         else:
            pass                         # -- file exists, we assume the socat is still running, let's reuse it
         d = sdev
   
   if preg_match("^rrf:(\S+)",d,m):
      host = m[1]
      import RepRapFirmwareAPI
      class RRFPseudoSerial(RepRapFirmwareAPI.RRFRestAPI):    
         def __init__(self,host):
            super().__init__(host)
         def read(self,n=255):                                    # -- emulate non-blocking read
            r = self.reply()
            #print(f"{json.dumps(r)}")
            if len(r)>0 and not re.search('\sok\n',r):
               r += "ok\n"
            #elif len(r)>0:
            #   r += "\n"
            return r.encode()
         def write(self,c):
            return self.gcode(c.decode(),"async")
      ser = RRFPseudoSerial(host)
      backend = 'rrf'

   else:
      if not os.path.exists(d):
         eprint(f"device {d} doesn't exist, abort",exit=1)
   
      lprint(f"opening serial <{d}>")   
      #ser = serial.Serial(d,rtscts=True,dsrdtr=True,timeout=0.05)  # -- stutters
      ser = serial.Serial(d,rtscts=True,timeout=0)     
      #ser = serial.Serial(d,timeout=0.05)                  # -- stutters

   time.sleep(2)                          # -- allow older/slower 8-bit boards to get ready

   if slicing['machine_uuid'] != "":
      uid = None
      for ask in ["M115","M122"]:
         writeSerial(ser,ask+"\n")
         _ = readSerial(ser)
         if preg_match('UUID\s*:\s*(\S+)',_,m):
            uid = m[1]
            break
         elif preg_match('Board ID\s*:\s*(\S+)',_,m):
            uid = m[1]
            break
         elif preg_match('MAC address\s*(\S+)',_,m):
            uid = m[1]
            break
      if slicing['machine_uuid'] == uid:
         iprint(f"authenticated \"{slicing['machine_name']}\" ({conf['printer']}): {uid}")
      else:
         eprint(f"printer not authenticated '{uid}' != '{slicing['machine_uuid']}' ({slicing['machine_name']})",exit=1)

   return ser
            
def printGcode(f):
   job = { }
   
   st = time.time()
   stu = st

   job['start_time'] = st
   job['start_date'] = datetime.datetime.fromtimestamp(job['start_time']).isoformat()
   
   if not os.path.exists(f):
      eprint(f"cannot read file <{f}> doesn't exist, ignored")
      return
         
   flen = os.path.getsize(f)
   
   cur_z = 0               # -- current Z
   lyn = 0                 # -- layer number

   em = 'abs'
   eabs = 0
   le = 0
   tool = 0
   
   def ftime(d,short=0):
      sp = ' '
      if short:
         sp = ''
      if d<2*60:
         return f"{int(d/60)}m{sp}{int(d)%60:02d}s"
      return f"{int(d/60/60)}h{sp}{int(d/60)%60:02d}m"
            
   def parse(l):
      m = [ ]
      nonlocal lyn, cur_z, le, em, eabs
      if preg_match('^;\s*LAYER:\s*(\d+)',l,m):
         lyn = graceful(int,m[1],on_error=0)
      if preg_match('Z([\d\.]+)',l,m):
         cur_z = graceful(float,m[1],on_error=0)
      if preg_match('^G92\s.*E([\d\.]+)',l,m):
         le = graceful(float,m[1],on_error=0)
      elif preg_match('^G[0123]\s.*E([\d\.]+)',l,m):
         e = graceful(float,m[1],on_error=0)
         if em == 'abs':
            eabs += e-le
         else:
            eabs += e
         le = e
      elif preg_match('^T(\d+)',l,m):
         tool = graceful(int,m[1],on_error=0)
      elif preg_match('^M82\s',l,m):   # -- E abs
         em = 'abs'
      elif preg_match('^M83\s',l,m):   # -- E rel
         em = 'rel'
      elif preg_match('^G90\s',l,m):   # -- abs pos (also E)
         em = 'abs'
      elif preg_match('^G91\s',l,m):   # -- rel pos (also E)
         em = 'rel'

   def update(fh):
      nonlocal stu, n_ok, tool
      if conf['verbose'] or conf['quiet'] or time.time()-stu < 1/5:
         return
      stu = time.time()
      fcur = fh.tell()
      tot = (time.time()-st) / (fcur/flen+.001) 
      eta = 0
      if st+tot > time.time():
         eta = max((st + tot) - time.time(),0)     # -- don't go below 0
      # output something like 'print3r: print: 0h 55m elapsed, eta 0h 00m, 100.0% complete, z=39.85mm, layer #89, filament 8.44m'
      print(f"{me}: print: {ftime(time.time()-st)} elapsed, eta {ftime(eta)}, {fcur/flen*100:.1f}% complete, z={cur_z:.2f}, layer #{lyn}, filament {eabs/1000:.3f}m   \r",end="",flush=True)
      if conf['display_update']:
         writeSerial(ser,f"M117 {fcur/flen*100:.0f}% ETA {ftime(eta,short=1)} L{lyn} T{tool}\n")
         n_ok += 1

   m = [ ]
   if preg_match('rrf:(\S+)',conf['device'],m):          # -- RRF/RepRapFirmware: upload file, print & delete file again
      def abort_print(*args):
         # -- actually send command to stop current print
         rrf.gcode("M25")                                # -- pause SD printing
         rrf.gcode("M0")                                 # -- cancel SD printing
         rrf.delete("/gcodes/current.gcode")
         clean_exit()
      import RepRapFirmwareAPI
      signal.signal(signal.SIGINT,abort_print)        # -- reassign SIGINT, so we can send optional abort-gcode
      rrf = RepRapFirmwareAPI.RRFRestAPI(m[1])
      if slicing['machine_uuid']!="":
         r = rrf.gcode("M122")
         for id in ['Board ID:\s*(\S+)','MAC address\s*(\S+)']:
            if preg_match(id,r,m):   
               uid = m[1]
               if uid == slicing['machine_uuid']:
                  iprint(f"authenticated \"{slicing['machine_name']}\" ({conf['printer']}): {uid}")
               else:
                  eprint(f"printer not authenticated '{uid}' != '{slicing['machine_uuid']}' ({slicing['machine_name']})",exit=1)
      rrf.upload(f,"/gcodes/current.gcode")           # -- uploading local file to current.gcode
      rrf.print("/gcodes/current.gcode")              # -- start printing right away
      conf['display_update'] = 0
      fh = open(f,"r")                                # -- we read along as far we know the remote printing does it too
      while 1:
         # -- e.g. "SD printing byte 7751/91503" or "Not SD printing"
         s = rrf.print_status()
         if preg_match("(\d+)\/(\d+)",s,m):
            if not conf['quiet'] or conf['verbose']:
               fcur = float(m[1])
               lprint(f"cur={fcur} / len={flen}",level=2)
               while fh.tell() < fcur:
                  l = fh.readline()             # -- we read as many lines tracking the same as remote
                  lprint(f"local {l}")
                  parse(l)
                  update(fh)
         elif preg_match("^Not SD printing",s,m):
            break
         time.sleep(1)
         webcamSnap()
      if not conf['quiet'] or conf['verbose']:
         print("")
      rrf.delete("/gcodes/current.gcode")
         
   else:
      def gcode(l):
         l = re.sub(';.*','',l)
         g = { }
         for kv in re.split('\s+',l):
            m = [ ]
            if preg_match('(\w)(.*)',kv,m):
               g[m[1]] = m[2]
         return g
   
      def abort_print(*args):
         writeSerial(ser,slicing['abort_gcode'])
         time.sleep(2)                                # -- give it some time before we sever connection
         if conf['verbose']==0 and not conf['quiet']:
            print("")
         clean_exit()
         
      ser = connectSerial(conf['device'])
      
      if not ser:
         eprint(f"cannot open device <{conf['device']}>, abort")
         return 
   
      fh = open(f,"r")
      if not fh:
         eprint(f"cannot read file <{f}>, abort file processing")
         return 
   
      lst = time.time()
   
      signal.signal(signal.SIGINT,abort_print)        # -- reassign SIGINT, so we can send optional abort-gcode
      
      webcamSnap()
   
      n_ok = 0
      n_queue = 0
      
      while ser.isOpen():
         l = fh.readline()
         g = gcode(l)
         if not l:    
            break
         parse(l)
         update(fh)
         if re.search('^\s*;',l):         # -- don't send plain comments
            continue
         l = re.sub('^\s+','',l)          # -- remove leading spaces
         if len(l)<=0:
            continue
         lprint(f"=> {json.dumps(l)}",level=2)
         ser.write(l.encode())
         n_ok += 1
         r = ''
         while 1:
            if ser.inWaiting():
               _ = ser.read(256)
               if len(_)>0:                                # -- read anything?
                  r += _.decode()                          # -- FIXME: here some runtime error could occur, if this happens, something terrible happened (bad cable, bad connection, out of sync systems etc), not sure if and how to recover
                  if len(_)<256:                           # -- complete read?
                     lprint(f"   <= {json.dumps(r)}",level=2)
                     n_ok -= r.count('ok\n') + r.count('ok ')
                     if n_ok<=n_queue:                     # -- we might fall below 0, either way we move on to next g-code line
                        n_ok = 0
                        break
            time.sleep(.005) 
            lprint(f"   waiting for response (n_ok={n_ok})",level=4)
            
         if time.time()-lst > 3:
            deviceLock(conf['device'],update=1)
            lst = time.time()
         
         webcamSnap()
            
      if conf['display_update']:
         writeSerial(ser,f"M117 print finished {ftime(time.time()-st,short=1)}\n")
         
      time.sleep(5)                            # -- allow print to end before close the connection
   
      ser.close()   
      
      deviceLock(conf['device'],unset=1)
      
      if conf['verbose']==0 and not conf['quiet']:
         print("")               # -- required to clear single line updates above with "\r"

   webcamSnap(end=1)          # -- let's take last webcam snapshot(s) of finished print

   # -- let's document the print
   job['time'] = job['end_time'] = time.time()
   job['end_date'] = datetime.datetime.fromtimestamp(job['end_time']).isoformat()
   job['duration'] = job['end_time']-job['start_time']
   job['uid'] = conf['uid'] if 'uid' in conf else str(uuid.uuid4())
   job['conf'] = conf
   job['slicing'] = slicing
   job['process'] = process
   job['args'] = sys.argv
   job['files'] = fs
   job['size'] = os.path.getsize(f)
   job['version'] = f"{APPNAME} {VERSION}"
   job['filament_used'] = eabs
   
   if not os.path.exists(os.path.join(os.getenv("HOME"),".prynt3r")):
      os.mkdir(os.path.join(os.getenv("HOME"),".prynt3r"))
   fhl = open(os.path.join(os.getenv("HOME"),".prynt3r","log.json"),"a")
   print(json.dumps(job),file=fhl)
   fhl.close()
   
   
def convertToMesh(f,fo):
   m = [ ]
   if preg_match('\.(scad)$',f,m):
      if 'scadlib' in conf:
         if not os.path.exists(conf['scadlib']):
            eprint(f"scadlib <{conf['scadlib']}> not found, abort",exit=1)
         fx = tmpfn('scad')
         with open(fx,"w") as fh:
            for l in conf['scadlib'].split(','):
               if not re.search('^/',l):
                  l = os.path.abspath(l)
               print(f"use <{l}>",file=fh)
            if 1:              
               print(f"include <{os.path.abspath(f)}>",file=fh)    # -- simpler
            else:
               with open(f,"r") as fh2:
                  print(fh2.read(),file=fh)
         f = fx
         tmp.append(fx)
      execx(['openscad','-o',fo,f])
   elif preg_match('\.(jscad)$',f,m):
      execx(['openjscad','-o',fo,f])
   elif preg_match('\.(zcad)$',f,m):
      execx(['openzcad','-o',fo,f])
   elif preg_match('\.(vdb)$',f,m):
      try:
         import pyopenvdb as vdb
         def triangulate(v,a=0.5):
            m = { "faces": [ ], "vertices": [ ] }
            p, ts, qs = v.convertToPolygons(adaptivity=a)
            m['vertices'] = p.tolist()
            m['faces'] = [ t.tolist()[::-1] for t in ts ]
            for q in qs:
               m['faces'].append([q[2],q[1],q[0]])
               m['faces'].append([q[3],q[2],q[0]])
            return m
      
         gs,meta = vdb.readAll(f)
         m = triangulate(gs[0])
         ms = trimesh.Trimesh(vertices=m['vertices'],faces=m['faces'])
         ms.export(fo)
      except Exception as e:
         eprint(f"pyopenvdb not installed or available, or failed to load otherwise:",e,exit=1)
   elif preg_match('\.(svg)$',f,m):
      fx = tmpfn('scad')
      with open(fx,"w") as fh:
         print(f"linear_extrude(height=10) import(\"{os.path.abspath(f)}\");",file=fh)
      f = fx
      tmp.append(fx)
      execx(['openscad','-o',fo,f])
   else:
      eprintf(f"unknown extension in <{f}>, don't know how to handle yet",exit=1)
      
def execx(a,**argv):
   lprint(f"exec {a}",level=2)
   p = subprocess.run(a,capture_output=True)
   if p.returncode:
      lprint(f"process {a[0]} returned non-zero: {p.returncode}",level=2)
      for l in p.stdout.decode().split("\n"):
         if len(l):
            eprint(l)
      for l in p.stderr.decode().split("\n"):
         if len(l):
            eprint(l)
      
   return p.returncode

def webcamSnap(end=0):
   if 'webcam' not in conf or len(conf['webcam'])==0:
      return
      
   def webcam_conf(s):
      c = { }
      for w in re.split('\s+',s):
         if len(w)==0: continue
         for kv in re.split('[;,]',w):
            k,v = kv.split(':')
            if re.search('^[\d\.]+$',v):
               v = float(v)
            c[k] = v
      if 'time' not in c: c['time'] = 60
      if 'delay' not in c: c['delay'] = 5
      if c['time'] <= c['delay']: c['time'] = c['delay']+1
      return c

   if 'webcam' not in process:
      process['webcam'] = { }
   if 'last' not in process['webcam']:
      process['webcam']['last'] = 0
   if 'snaps' not in process['webcam']:
      process['webcam']['snaps'] = [ ]

   dir = os.path.join(os.getenv('HOME'),'.prynt3r','snaps')
   if not os.path.exists(dir):
      os.makedirs(dir)
      
   wc = webcam_conf('')
   if 'webcam_conf' in conf:
      wc = webcam_conf(conf['webcam_conf'])
   if 'webcam_snap' in conf:
      wc = webcam_conf(conf['webcam_snap'])
      
   if end or process['webcam']['last'] + wc['time'] < time.time():
      wcs = [ ]
      if 'webcam_settings' in conf:
         wcs = [ webcam_conf(a) for a in re.split('\s+',conf['webcam_settings']) ]
      for i,w in enumerate(re.split('\s+',conf['webcam'])):
         if len(w)==0: continue
         if re.search('^/dev/',w) and not os.path.exists(w):      # -- remote webcams we can't probe for existence
            lprint(f"webcam device <{w}> does not exist, ignored")
            continue
         wcb = wc.copy()
         if i<len(wcs) and type(wcs[i])==dict:
            wcb |= wcs[i]
         fno = os.path.join(dir,f"{datetime.datetime.now().strftime('%Y%m%d %H%M%S')}")
         nick = os.getpid()
         if 'printer' in conf:
            nick = conf['printer']
         if 'machine_name' in conf:
            nick = conf['machine_name']
         nick = re.sub('[\W ]+','_',nick)
         fno += " - "+nick
         fno += "."+str(i)
         fno += ".jpg"
         lprint(f"take webcam snap #{i} to {fno} conf={json.dumps(wc)}")
         if os.fork()==0:
            #def nothing(): pass
            #signal.signal(signal.SIGINT,nothing)
            signal.signal(signal.SIGINT,sigint_orig)
            # -- NOTE: -nostdin is essential, otherwise ffpmep tampers with parent's stdin/ioctl console
            p = subprocess.run(['ffmpeg','-nostdin','-i',w,'-ss',str(wcb['delay']),'-r','1','-vsync','1','-qscale','1','-frames:v','1','-f','image2',fno],capture_output=True)     
            if not os.path.exists(fno):
               lprint(f"capture webcam <{w}> failed")
               lprint(p,level=3)
            else:
               if 'rotate' in wcb:
                  tf = tmpfn('jpg')
                  subprocess.run(['convert',fno,'-rotate',str(wcb['rotate']),tf])
                  shutil.move(tf,fno)
            sys.exit(0)
         process['webcam']['snaps'].append(fno)
      process['webcam']['last'] = time.time()

   if end:
      time.sleep(2+wc['delay'])                          # -- allow last webcam to be taken
      stats = { "total": 0, "exists": 0 }
      for f in process['webcam']['snaps']:
         if os.path.exists(f):
            stats['exists'] += 1
         stats['total'] += 1
      if stats['total'] > 0 and stats['total']!=stats['exists']:
         iprint(f"WARN: webcam: {stats['exists']} snapshots taken, out of {stats['total']} total requested or {100-100/stats['total']*stats['exists']:.0f}% missing")

def loadMesh(fn):
   if re.search('\.3mj$',fn):
      with open(fn,"r") as fh:
         e = json.load(fh)
         fs = [ ]
         for v in m['volumes']:
            f.extend([ f['v'] for f in v['triangles'] ])
         return trimesh.Trimesh(vertices=vertices.e['vertices'],faces=fs)
   return trimesh.load(fn)
   
def nstr(*args,sep=','):                  # -- nicer str() without [ ] for list or tuple
   s = ''
   for i,a in enumerate(args):
      if i>0:
         s += sep
      if type(a)==list or type(a)==tuple:
         s += sep.join([nstr(_) for _ in a])
      elif type(a)==dict:
         for k,v in a.items():
            s += f"{k}: {nstr(v)}" 
      elif type(a)==str:
         s += a
      else:
         s += f"{float(a):.2f}"
   return s   

def graceful(*args,**argv):               # -- graceful calling function, optional on_error with default value in case of error
   args = list(args)
   f = args.pop(0)
   try:
      return f(*args)
   except:
      pass
   if 'on_error' in argv:
      return argv['on_error']
      
def lprint(*args,**argv):
   if ('level' in argv and argv['level']<=conf['verbose']) or ('level' not in argv and conf['verbose']):
      if 'level' in argv:
         del(argv['level'])
      print(f"{me}: {datetime.datetime.now().isoformat()}:",*args)

def eprint(*args,**argv):
   print(f"{me}: {datetime.datetime.now().isoformat()}: ERROR:",*args)
   if 'exit' in argv and argv['exit']:
      clean_exit(argv['exit'])

def iprint(*args):
   if not conf['quiet']:
      print(f"{me}:",*args)
   
def pprint(*args,start=False,end=False,tail=False):
   if conf['verbose']==0:
      a = [ ]
      if not start and not tail:
         a.append(",")
      elif start:
         a.append("-")
      a.extend(args)
      print(*a,end=("\n" if end or tail else ""),flush=True)
   else:
      lprint(*args)

def mopen(f,m="r"):
   for b in basedirs:
      if os.path.exists(os.path.join(b,f)):
         return open(os.path.join(b,f),m)

def ipaths(f,m="r"):
   return iter([ os.path.join(b,f) for b in basedirs if os.path.exists(os.path.join(b,f))])

# -----------------------------------------------------------------------------------------------------

sigint_orig = signal.getsignal(signal.SIGINT)
   
signal.signal(signal.SIGINT, clean_exit)

s2l = { "o": "output", "p": "printer", "v": "verbose", "d": "device", "s": "slicer", "k": "keep", "x": "extended" }
s2a = { "o": 1, "p": 1, "d": 1, "s": 1 }
preproc = { "scad": "stl", "jscad": "stl", "zcad": "stl", "vdb": "obj", "svg": "stl" }
inline_code = "scad,jscad,zcad".split(',')

post = { }
process = { }
fs = [ ]
i = 0
while i < len(sys.argv):
   a = sys.argv[i]
   m = [ ]
   if preg_match('^-(\w+)$',a,m):
      for k in m[1]:
         if k in s2a:
            i += 1
            conf[s2l[k]] = sys.argv[i]
         elif k in s2l:
            if s2l[k] not in conf:
               conf[s2l[k]] = 0
            conf[s2l[k]] += 1
         if k in s2l:
            conf_src[s2l[k]] = 'cli'
   elif preg_match('^--([\w\.\-]+)$',a,m):
      k = m[1]
      k = re.sub('-','_',k)
      conf[k] = 1
      conf_src[k] = 'cli'
   elif preg_match('^--([\w\.\-]+)=(.*)$',a,m):
      k,v = m[1],m[2]
      k = re.sub('-','_',k)
      if preg_match('^post_(\w+)',k,m):
         post[m[1]] = v
      conf[k] = v
      conf_src[k] = 'cli'
   elif preg_match('^@(\S+)$',a,m):
      found = 0
      for f in ipaths(os.path.join("macro",m[1]+".ini")):
         found = 1
         for k,v in parse_ini(f).items():
            conf[k] = v
            conf_src[k] = f"macro {m[1]}"
      if not found:
         eprint(f"unknown macro <{m[1]}> not found anywhere",exit=1)
   else:
      fs.append(a)
   i += 1

cmd = ''

if 'help' in conf:
   usage()

if 'version' in conf:
   print(f"{APPNAME} {VERSION}")
   sys.exit(0)
   
if len(fs):
   iprint(f"== {APPNAME} {VERSION} == {APPREPO}")

if len(fs):
   cmd = fs.pop(0)
elif len(fs) and os.path.exists(fs[0]):
   iprint("WARN: no command given, 'print' assumed")
   cmd = 'print'

if 1:
   fh = mopen(os.path.join("slicer","slicers.json"),"r")
   if fh:
      slicer = json.load(fh)
      fh.close()
   else:
      eprint(f"no <{os.path.join('slicer','slicers.json')}> found anywhere: {basedirs}")
   
#if cmd in ['slice','preview','print','gconsole']:
if cmd not in ['client','log']:
   for f in ipaths(os.path.join("printer","default.ini")):     # -- base for all settings (slicer/printer independent)
      for k,v in parse_ini(f).items():
         if k in conf_src: 
            continue
         conf[k] = v
   
   if 'printer' in conf:
      found = 0
      for f in ipaths(os.path.join("printer",f"{conf['printer']}.ini")):   # -- printer specifics (slicer/printer independent)
         for k,v in parse_ini(f).items():
            if k in conf_src: 
               continue
            conf[k] = v
         found += 1
      if found==0:
         eprint(f"no printer config/profile found anywhere for <{conf['printer']}>")
         
   if 1:
      if 'prepend_gcode' in conf:
         conf['start_gcode'] += "\n"+conf['prepend_gcode']

      for k in conf:                                              # -- transfer conf into slicing
         if k not in intern_keys:
            slicing[k] = conf[k]

   if conf['verbose']:
      lprint("conf:",json.dumps(conf,indent=3))
      lprint("slicing:",json.dumps(slicing,indent=3))
   
   for k in "machine_width,machine_depth,machine_height".split(","):
      slicing[k] = float(slicing[k])

if cmd=='slice' or cmd=='preview' or cmd=='print':
   iprint(f"conf: \"{slicing['machine_name']}\" ({conf['printer']}), device: {conf['device']}, build/v: {slicing['machine_width']}x{slicing['machine_depth']}x{slicing['machine_height']}, layer/h: {slicing['layer_height']}, nozzle/d: {slicing['nozzle_diameter']}")

   #for k in "webcam".split(","):
   #   lprint(f"WARN: {k} not yet supported, coming soon",level=0)
   
   fsm = [ ]    # -- meshs
   fsg = [ ]    # -- gcode

   def place_mesh(m):                  # -- only needed for meshs which need to be placed absolute (like for cura*), otherwise we rather change bed-center 
      if conf['slicer'] in ['cura','cura4','cura5','cura-slicer']:
         mm = m.bounds
         sz = mm[1]-mm[0]
         if 'placement' in conf and conf['placement']!='none':
            pos = [ 0, 0 ]    # -- cura's default to center of bed, hence pos is relative (not abs) to machine_width/depth center
            pos = [ pos[i] - sz[i]/2 for i in range(2) ]   # -- center piece to center of bed
            if conf['placement']=='random':
               pos[0] += random.uniform(-1,1)*(slicing['machine_width']*.45-sz[0]/2)
               pos[1] += random.uniform(-1,1)*(slicing['machine_depth']*.45-sz[1]/2)
            m.apply_translation([pos[0],pos[1],0])
   
   for i,f in enumerate(fs):
      pprint(f"processing <{f}>",start=True)

      inline = [ e for e in conf if e in inline_code ]

      m = [ ]
      if len(inline):
         ext = inline[0]
         pprint(f"converting inline {ext}: {f}")

         src = f

         f = tmpfn(ext)

         fh = open(f,"w")
         if ext=='scad' and not re.search(';\s*$',src):
            src += ";"
         print(src,file=fh)
         fh.close()

         tmp.append(f)

         fm = tmpfn(preproc[ext])
         convertToMesh(f,fm)
         tmp.append(fm)
         f = fm

      if preg_match('\.gcode$',f,m):
         fsg.append(f)

      elif preg_match('\.(\w+)$',f,m):
         ext = m[1]

         if ext in preproc:
            fm = re.sub('\.(\w+)$',"."+preproc[ext],f)
            convertToMesh(f,fm)
            tmp.append(fm)
            f = fm
            ext = preproc[ext]

         if conf['recenter'] or conf['relevel'] or 'rotate' in conf or 'scale' in conf: # or 'placement' in conf:
            pprint(f"prepare")

            m = loadMesh(f)
            mm = m.bounds
            sz = [ mm[1][i]-mm[0][i] for i in range(3) ]
   
            # -- recenter X,Y and level Z 
            if conf['placement']!= 'none' and (('recenter' in conf and conf['recenter']) or ('relevel' in conf and conf['relevel'])):
               tr = [-(mm[0][j]+mm[1][j])/2 for j in range(3)]
               pprint(f"reposition <{nstr(tr)}>")
               m.apply_translation(tr)
   
            if 'rotate' in conf:
               if re.search(',',conf['rotate']):
                  rt = [ float(f)/180*math.pi for f in conf['rotate'].split(',') ]
               else:
                  eprint(f"bad rotation <{conf['rotate']}>, should be <xr>,<yr>,<zr> like 90,0,0")
               pprint(f"rotate <{nstr([a/math.pi*180 for a in rt])}>")
               if rt[0]:
                  m.apply_transform(trimesh.transformations.rotation_matrix(rt[0],[1,0,0]))
               if rt[1]:
                  m.apply_transform(trimesh.transformations.rotation_matrix(rt[1],[0,1,0]))
               if rt[2]:
                  m.apply_transform(trimesh.transformations.rotation_matrix(rt[2],[0,0,1]))

            if 'scale' in conf:
               if re.search(',',conf['scale']):
                  sc = [ ]
                  abs = -1
                  for i,f in enumerate(conf['scale'].split(',')):
                     if re.search('mm$',f):
                        f = float(re.sub('mm$','',f))
                        fa = f / (mm[1][i]-mm[0][i])
                        f = fa
                        abs = i                                # -- keep record which axis is absolute defined
                     else:
                        f = float(f)
                     sc.append(f)
                  if abs >= 0:
                     sc = [ sc[abs] if f==0 else f for i,f in enumerate(sc) ]    # -- any axis with scale = 0 => scale same as abs axis
               else:
                  sc = [float(conf['scale']) for i in range(3) ]
               pprint(f"scale <{nstr(sc)}>")
               m.apply_scale(sc)

            if 'relevel' in conf and conf['relevel']:
               mm = m.bounds
               pprint(f"relevel {-mm[0][2]:.3f}")
               m.apply_translation([0,0,-mm[0][2]])

            place_mesh(m)

            if 'translate' in conf:
               v = [ float(a) for a in conf['translate'].split(',') ]
               pprint(f"translate <{nstr(v)}>")
               m.apply_translation(v)
               
            pprint(f"size {nstr(list(m.bounds[1]-m.bounds[0]),sep='x')}")
            
            if conf['slicer'] in slicer:
               fmt = list(slicer[conf['slicer']]['formats'].keys())[0]  # -- prefered format
            else:
               fmt = 'stl'
            fm = tmpfn(fmt)
            tmp.append(fm)
            lprint(f"mesh {list(m.bounds[1]-m.bounds[0])}: {[list(v) for v in list(m.bounds)]}")

            lprint(f"export to <{fm}>")
            m.export(fm)                                       # -- we need to save the changed mesh again
            f = fm
            fsm.append(f)
      else:
         lprint(f"WARN: strange filename <{f}>, cannot determine what to do, skipped",level=0)
      pprint("",tail=True)

   pprint("preparing",start=True)   

   # -- at this point, we have all the meshes, ready to slice

   if 'multiply_part' in conf:
      n = int(conf['multiply_part'])
      pprint(f"multiply part {n}x") #,start=True)
      fsm = [ m for i in range(n) for m in fsm ]
      #pprint("",tail=True)
      
   if len(fsm)>1: # and 'multi_file' in slicer[conf['slicer']] and not slicer[conf['slicer']]['multi_file']:      
      # -- merge multiple repositioned meshes into one
      pprint(f"merge {len(fsm)} part(s)") #,start=True)
      xp,yp = 0,0
      ys = 0
      wn = int(math.sqrt(len(fsm)))
      if 'cols' in conf:
         wn = int(conf['cols'])
      elif 'rows' in conf:
         wn = int(len(fsm)/int(conf['rows']))
      ms = [ ]
      n = 0
      for f in fsm:
         m = loadMesh(f)
         mm = m.bounds
         sz = mm[1]-mm[0]
         if 'cols' in conf:
            if n>0 and n%wn == 0:
               xp = 0
               yp += ys + 5
         elif xp+sz[0] > slicing['machine_width']*.9:
            xp = 0
            yp += ys+5
         lprint(f"repos #{n} {[xp,yp]}")
         m.apply_translation([-mm[0][0]+xp,-mm[0][1]+yp,0])
         ys = max(sz[1],ys)
         xp += sz[0]+5
         n += 1
         ms.append(m)

      m = trimesh.util.concatenate(ms)

      place_mesh(m)
      
      lprint(f"mesh {list(m.bounds[1]-m.bounds[0])}: {[list(v) for v in list(m.bounds)]}")
            
      fmt = list(slicer[conf['slicer']]['formats'].keys())[0]
      f = tmpfn(fmt)
      m.export(f)
      #m.export("test.stl")
      tmp.append(f)
      fsm = [ f ]
   
   if len(fsm):                  # -- any mesh to process?
      pprint(f"slicing part{'s' if len(fsm)>1 else ''} ({conf['slicer']})") #,start=True)
      if 'output' in conf:
         fo = conf['output']
         if os.path.exists(fo):
            os.remove(fo)
         pprint(f"output to <{fo}>")
      else:
         fo = tmpfn('gcode')
         tmp.append(fo)
      sliceMesh(fsm,fo,m)
      fsg.append(fo)

   pprint("",tail=True)

   #if 'post' in conf:
   #   for p in conf['post'].split(','):
   #      subprocess.run([])

   # -- at this point, we have all the gcode file(s)
   for f in fsg:
      if cmd == 'preview':
         previewGcode(f)
      if cmd == 'print':
         printGcode(f)
      
elif cmd == 'gconsole':
   #from prompt_toolkit import prompt
   ser = connectSerial(conf['device'])
   iprint(f"Hint: use CTRL-C or type 'quit' or 'exit' to quit the session")
   while 1:
      print("> ",end="",flush=True)
      l = sys.stdin.readline()      # -- no history or repeat command, but works as expected (doesn't block ser.write() below)
      #l = prompt('')    # -- holds ser.write() back
      #l = input()       # -- holds ser.write() back too (facepalm)
      if re.search('(quit|exit)',l):
         break
      ser.write(l.encode())
      lprint(f"sent <{l}>")
      t = time.time()
      while 1:
         s = ""
         while 1:
            _ = ser.read(255)
            s += _.decode()
            if len(_)<255:
               break
         if len(s):
            sc = s
            sc = re.sub('ok\n','\x01',s)
            sc = re.sub('(\x01+)',lambda x: "ok\n" if len(x.group(1))<=1 else f"ok [{len(x.group(1))}x]\n",sc)
            print(f"% {sc}")   
         if re.search('ok\n',s):
            break
         if time.time()-t > 10:
            break
         time.sleep(0.01)
         
elif cmd == 'log':
   n = 0      
   eabs = { }
   tasks = { }

   def disp(e):
      if 'filament_used' not in e:
         e['filament_used'] = 0
      if conf['verbose']>0 or 'extended' in conf or 'output' in conf:
         if 'extended' in conf:
            print(json.dumps(e,indent=3))
         elif 'output' in conf:
            o = { }
            for k in conf['output'].split(','):
               if k in e:
                  o[k] = e[k]
               else:
                  for s in 'conf slicing process args'.split(' '):
                     if s in e and k in e[s]:
                        o[k] = e[s][k]
                     elif k==s and s in e:
                        o[s] = e[s]
            print(json.dumps(o))
         else:
            print(json.dumps(e))
      else:
         ago = (time.time()-e['end_time'])/60/60
         ago = f"{int(ago/24)%24}d {ago%24:.0f}h ago"
         _ = ', '.join([os.path.basename(f) if re.search('\.\w+$',f) else f for f in e['files']])
         print(f"#{n}: {e['conf']['machine_name']} ({e['conf']['printer']}): {_} {ago}, {e['filament_used']/1000:.3f}m")
         xtr = f'{" ".join([f"--{k}="+e["conf"][k] for k in "scale,rotate".split(",") if k in e["conf"] ])}'
         if len(xtr): print("   ",xtr)
            
   if len(fs):
      iprint(f"querying {fs}")

   fh = open(os.path.join(os.getenv("HOME"),".prynt3r","log.json"),"r")
   
   catch = -1
   m = [ ]

   hits = 0
   
   if len(fs)>0 and preg_match('^#(\d+)$',fs[0],m):
      catch = int(m[1])

   for l in fh.readlines():
      e = json.loads(l)
      if e['conf']['printer'] not in eabs:
         eabs[e['conf']['printer']] = 0
      if e['conf']['printer'] not in tasks:
         tasks[e['conf']['printer']] = 0
      h = 0
      if len(fs):
         if catch>=0:
            if n==catch:
               h = 1
         else:
            l_ = l.lower()
            for f in fs:
               if l_.find(f.lower())>=0:
                  h += 1
            if h == len(fs):
               h = 1
            else:
               h = 0
      else:
         h = 1
      if h:
         disp(e)
         if 'filament_used' in e:
            eabs[e['conf']['printer']] += e['filament_used']
         tasks[e['conf']['printer']] += 1
         hits += 1
      n += 1

   if not (conf['verbose']>0 or 'extended' in conf):
      etot = sum([v for v in eabs.values()])
      print(f"   {hits} entries, {etot/1000:.3f}m filament used (~{etot/1000/330:.1f}kg)")
      if etot==0:
         etot = 1
      if len(eabs.keys())>1:
         l = sorted(eabs.items(), key=lambda k: k[0])          # -- by key
         # l = sorted(eabs.items(), key=lambda k: k[1])[::-1]    # -- by value, highest first
         for kv in l:
            k,v = kv
            if v>0:
               print(f"      {k}: {tasks[k]:,} prints, {v/1000:.3f}m ~{v/1000/330:.1f}kg ({100/etot*v:.1f}%)")
   sys.exit(0)
   
elif cmd == 'client':
   if not os.path.exists(conf['device']):
      eprint(f"<{conf['device']}> doesn't exist",exit=1)
   f = tmpfn("cfg")
   fh = open(f,"w")
   if not fh:
      eprint(f"could not create config file for set2net: {f}")
   p = 3380
   m = [ ]
   n = 0
   if preg_match('(\d+)$',conf['device'],m):
      n = int(m[1])
      p += n
   print(f"{p}:raw:600:{conf['device']}:{conf['baudrate']} 8DATABITS NONE 1STOPBIT -XONXOFF LOCAL -RTSCTS",file=fh)
   fh.close()
   tmp.append(f)
   
   if os.fork()==0:   
      p = subprocess.run(["ser2net","-n","-c",f])
   if not conf['quiet']:
      iprint(f"client started, use --device=tcp:<hostip>:{n} on the host")
      iprint(f"use CTRL-C to kill/end gateway")
      iprint(f"NOTE: anybody on your local network has the capability to access &")
      iprint(f"      control this printer; it is YOUR RESPONSIBILITY to secure")
      iprint(f"      your local network from unauthorized use of your printer(s)")
   os.wait()
   clean_exit()
      
else:
   if len(cmd):
      eprint(f"unknown command <{cmd}>: only print, slice, preview, log or client available")
   usage()

clean_exit()
